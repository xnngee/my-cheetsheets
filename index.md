# GIT --- Cheet Sheet

> :warning: **WIP:** Этот файл находится в разработке.


## Основные команды

### Инициализация
- `git init` \
*Инициализация нового локального Git репозитория в текущей директории*

### Статус
- `git status` \
*Показывает статус рабочего дерева, включая файлы, которые добавлены, изменены или удалены.*

### История коммитов
- `git log` \
*Показать историю коммитов*
- `git log --merge` \
*Показать конфликт слияний*

### Конфигурация
- `git config` \
*Управление конфигурацией Git*
    - `git config user.name` \
    *Получить текущее имя пользователя*
    - `git config user.email` \
    *Получить текущий email пользователя*
    - `git config --global user.name "xenongee"`
    - `git config --global user.email "rublgleb@gmail.com"` \
    *Установить глобальное[^1] имя пользователя и email*
    - `git config --list` \
    *Список всех настроек конфигурации*
        - `cat ~/.gitconfig` \
        *Просмотр содержимого глобального конфигурационного файла Git*

### Staging area
- `git add` \
*Добавить файл в Staging area (индекс)[^2] для отслеживания изменений*
    - `git add .` \
    *Добавить все изменённые файлы в текущем каталоге и подкаталогах*
    - `git add <file>` \
    *Добавить конкретный файл*
    - `git add -p` \
    *Интерактивно добавить файлы*

### Коммиты
- `git commit` \
*Создать коммит с изменениями из Staging area*
    - `git commit -m "commit message"` \
    *Создать коммит с сообщением*
    - `git commit -m "commit message" -m "additional commit message"` \
    *Создать коммит с сообщением и c дополнительным сообщением*
    - `git commit -am "commit message"` \
    *Создать коммит с сообщением, добавить все изменённые файлы (пропускаем этап добавления изменений в Staging area, однако вам все равно нужно запустить `git add`, чтобы начать отслеживать новые файлы)*
    - `git commit --amend` \
    *Изменить последний коммит* \
    *Сообщение коммита будет изменено во внешнем редакторе (nano\vim)* \
    *Для отправки изменения в файле не забудьте добавить файл в Staging area `git add` или `git add -a --amend`*
    - `git commit --amend -m "commit message"` \
    *Изменить последний коммит с сообщением*
    - `git commit --amend --no-edit` \
    *Изменить последний коммит без изменения сообщения*

## Checkout, ветки, слияние веток, HEAD [^3], тэги, switch
### Checkout
- `git checkout` \
*Переключиться на другой коммит, ветку или тег, откат файла к последнему коммиту*
    - `git checkout <..>` \
    *Переключиться на конкретный коммит или ветку*
    - `git checkout master\main` \
    *Переключиться на ветку master\main*
    - `git checkout -b <branch>` \
    *Создать новую ветку и переключиться на неё*

### Ветки
- `git branch` \
*Показать список веток*
    - `git branch <branch>` [^5] \
    *Создать новую ветку [^4]*
    - `git branch -d [--delete] <branch>` \
    *Удалить ветку [^10]*


### Слияние веток
- `git merge` \
  *Слияние веток [^6]*
  - `git merge <branch>` \
  *Слить ветку в текущую ветку*
  - `git merge --abort` \
  *Отменить слияние веток*

### Тэги
- `git tag` \
  *Показать список тегов*
  - `git tag <tag>` \
  *Создать новый тег*

### Switch (переключиться на другую ветку) [^7]
- `git switch <branch>` \
*Переключиться на другую ветку*
    - `git switch --detach <commit\tag>` \
    *Переключиться на конкретный коммит или тег*
    - `git switch -c <branch>` \
    *Создать новую ветку и переключиться на неё*

### Показать список файлов в рабочем дереве
- `git ls-files` \
*Показать список файлов в рабочем дереве*

## Удаление [^8]\откат изменений

### Откат изменений
- `git restore` \
*Отменить изменения в файлах*
    - `git restore --staged <file\path-to-file>` \
    *Отменить изменения в файле или директории в Staging area*
    - `git restore <file\path-to-file>` \
    *Отменить изменения в файле или директории в рабочем дереве*

### Удаление файлов
- `git rm` \
*Удалить файл из рабочего дерева и из индекса*
    - `git rm <file>` \
    *Удалить файл из рабочего дерева и из индекса*
    - `git rm -r <directory-with-files>` \
    *Удалить (рекурсивно) директорию с файлами из рабочего дерева и из индекса*
    - `git rm -f <file>` \
    *Удалить форсированно*
    - `git rm --cached <file>` \
    *Удалить кэшированную версию файла*

- `git clean` \
*Удалить неотслеживаемые файлы [^9] из рабочего дерева*
    - `git clean -n` \
    *Показать список файлов, которые будут удалены*
    - `git clean -d` \
    *Удалить неотслеживаемые файлы и директории из рабочего дерева*
    - `git clean -f` \
    *Удалить форсированно*
    - `git clean -dn`
    - `git clean -df`

- `git reset` \
*Отменить изменения в рабочем дереве и индексе*
  - `git reset --soft HEAD~1` \
  *Отменить последний коммит, изменения оставить и в файле, и в индексе*
  - `git reset HEAD~1` \
  *Отменить последний коммит, изменения оставить в файле, но не в индексе*
  - `git reset --hard HEAD~1` \
  *Перманентно удалить последний коммит с измененияями*

### Detached Commit in detached HEAD
Вносим изменения в уже совершённом коммите.

1. **Переход в режим Detached HEAD** \
Используем `git checkout` с идентификатором коммита, чтобы перейти в режим отсоединённой HEAD. \
В этом режиме HEAD указывает на определённый коммит, а не на ветку.

2. **Внесение изменений** \
Внесите необходимые изменения в файлы. Проверьте статус изменений: `git status` \
Добавьте изменения в индекс: `git add <file>`. Создайте новый коммит с изменениями: `git commit -m "commit message"`.

3. **Сохранение изменений** \
В режиме Detached HEAD *созданный коммит не привязан ни к одной ветке*. \
Чтобы сохранить изменения:
   - Создайте новую ветку на основе текущего коммита: \
     `git branch <new-branch-name>`
   - Переключитесь на созданную ветку: \
     `git switch <new-branch-name>`

4. **Слияние веток** \
Переключитесь на ветку `master`: `git switch master`. Соедините изменения из созданной ветки `git merge <new-branch-name>.` \
В случае конфликтов:
   - Разрешите конфликты вручную в файлах или через редактор (VS Code).
   - Добавьте исправленные файлы в индекс `git add <file>` и завершите слияние `git commit`

- **Просмотр коммитов через reflog** \
Используйте `git reflog`, чтобы просмотреть историю всех действий, включая создание коммитов, переключение веток и другие операции: \
Эта команда показывает хеши коммитов и временную метку каждой операции. Если коммит не привязан ни к одной ветке, он всё ещё может быть найден в `reflog` до удаления сборщиком мусора (GC). \
Чтобы восстановить такой коммит, можно переключиться на него или создать ветку, как это показано в шаге 3.

- **Gitignore** \
Чтобы игнорировать файлы, которые не нужно отслеживать, можно создать файл `.gitignore` в корневом каталоге репозитория. В этом файле можно указать список имен файлов или директорий, которые следует игнорировать.

## Продвинутая работа с Git
### Stash
- `git stash` \
*Сохранить изменения в рабочем дереве в стек изменений (черновик, тайник) [^11]*
    - `git stash list` \
    *Показать список всех сохранённых stash*
    - `git stash apply stash@{[index]}` \
    *Применить изменения из stash по индексу*
    - `git stash pop` \
    *Применить изменения из stash и удалить его из списка*
    - `git stash clear` \
    *Удалить все stash*

### Reflog
- `git reflog` \
*Показать список всех действий в репозитории*

[^1]: Глобальная конфигурация применяется ко всем репозиториям в системе.
[^2]: **Staging area** (индекс, область подготовленных изменений) --- это промежуточная область, где фиксируются изменения перед их сохранением в истории репозитория. Это позволяет разработчику управлять тем, какие изменения войдут в следующий коммит. \
Перед тем, как изменения в файле будут зафиксированы (с помощью commit), файл должен быть добавлен в эту область. \
\
-- Изначально файл Untracked (неотслеживаемый). После выполнения команды `git add` файл становится Staged (отслеживаемый). \
-- После выполнения команды `git commit` файл приобретает статус Unmodified (неизмененный) или Commited (зафиксированный). \
-- При удалении файла из рабочего дерева он получает статус Unmodified (неизмененный). \
-- При внесении изменений в файл он становится Modified (измененный), затем с помощью команды `git add` переходит в состояние Staged (отслеживаемый).
[^3]: **HEAD** --- это указатель Git, который показывает на текущий коммит в репозитории. Это тот коммит, от которого будут проходить дальнейшие изменения или коммиты. \
При переключении между ветками командой `git checkout`, HEAD автоматически перемещается на последний коммит выбранной ветки. После внесения изменений в файлы, добавления их в Staging area и создания нового коммита, HEAD обновляется и указывает на этот новый коммит в текущей ветке. \
**Detached HEAD** --- состояние указателя HEAD, при котором он ссылается на определённый коммит, а не на ветку. Вы можете перейти к конкретному коммиту, чтобы изучить состояние репозитория в точке этого коммита. HEAD будет указывать на выбранный коммит без привязки к ветке. \
Файл `.git/HEAD`: Внутри скрытой папки `.git` находится файл `HEAD`, содержащий сведения о текущем положении HEAD. Используя команды типа `cat .git/HEAD`, можно узнать, на какой коммит или ветку в данный момент указывает HEAD. \
Возвращение к ветке: Чтобы выйти из состояния Detached HEAD и вернуться к работе с ветками, достаточно выполнить git checkout на имя ветки, например, в master. Таким образом, HEAD снова будет указывать на последний коммит активной ветки.
[^4]: Cоздания новой ветки не влияет на основную master ветку. После разработки новой функциональности на новой ветке, она может быть слита с основной master веткой.
[^5]: Название ветки может содержать только буквы, цифры, дефисы и символы подчёркивания, но может содержать пробелы.
[^6]: **Слияние веток** (branch merge) --- это процесс объединения изменений из одной ветки в другую. Это позволяет разработчикам объединять изменения из разных веток в одну ветку, чтобы создать единую историю коммитов. \
Процесс слияния: \
-- Переключиться на ветку, в которую нужно слить изменения - `git checkout master`. \
-- Выполнить слияние - `git merge devBranch`. \
При слиянии ветки X в ветку Y, ветка X не удаляется сама по себе.
[^7]: **Команда** `git switch` --- альтернатива `git checkout` для переключения между ветками. В отличие от `git checkout`, команда `git switch` специализируется только на переключении веток и включает дополнительные проверки безопасности. Например, она автоматически остановит операцию, если обнаружит риск потери несохраненных локальных изменений. Однако с помощью ключа `--detach` можно переключиться на конкретный коммит или тег.
[^8]: **Команда** `git restore` --- альтернатива `git checkout` для отката изменений, возвращая последний коммит указанного файла. \
Удалить файл можно простым способом, так и альтернативным. \
\
Простой способ: \
-- Удалить файл с помощью команды `rm -rf <filename>`, либо через графический интерфейс. \
-- Проверяем что файл\директория удалены через `git status` и добавляем изменения в Staging area с помощью `git add .`. \
-- Создаем коммит с помощью `git commit -m "message"`. \
\
Альтернативный способ с помощью команды `git rm <filename>`: \
-- Удалить файл с помощью команды `git rm <filename>`. \
-- Проверяем что файл\директория удалены через `git status` или `git ls-files`. \
-- Создаем коммит с помощью `git commit -m "message"`.
[^9]: **Команда** `git clean` используется для удаления неотслеживаемых файлов и директорий из рабочего дерева. Неотслеживаемые файлы --- это файлы, которые не были добавлены в индекс с помощью `git add` и не были зафиксированы в коммите. \
Использование `git clean -n` (или `-dn`) для предварительного просмотра удаляемых файлов и `git clean -f` (или `-df`) для фактического удаления.\
Еще раз: `git clean` удаляет только файлы, не добавленные в индекс (не staged)
[^10]: До удаления ветки нужно убедиться, что вы не находитесь в этой ветке. Используйте `git branch` для просмотря текущей ветки. \
Если попытаться удалить ветку, находясь в ней, Git выдаст ошибку об использовании ветки. \
Используйте `git log` и `git branch` для проверки, была ли ветка успешно удалена. Убеждаемся в отсутствии удалённой ветки в списке. \
Важное замечание: При удалении ветки все невлитые коммиты тоже удаляются. Следует удалять ветку только после того, как её изменения были влиты в главную ветку и ветка больше не нужна. \
Это поможет поддерживать проект организованным и сократить количество неактивных веток.
[^11]: **Команда** `git stash` используется для временного сохранения изменений в рабочем дереве, чтобы вы могли переключиться на другую ветку или выполнить другие операции, не затрагивая текущие изменения. \
Раньше без этой команды нужно было коммитить изменения, создавать новую ветку, а затем удалить коммит из исходной ветки. \
[^12]:
[^13]:
[^14]:
[^15]:
[^16]:
[^17]:
[^18]:
[^19]:
[^20]:
