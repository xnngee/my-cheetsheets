# GIT --- Cheet Sheet

> :warning: **WIP:** Этот файл находится в разработке.


## Основные команды

### Инициализация
- `git init` \
*Инициализация нового локального Git репозитория в текущей директории*

### Статус
- `git status` \
*Показывает статус рабочего дерева, включая файлы, которые добавлены, изменены или удалены.*

### История коммитов
- `git log` \
*Показать историю коммитов*
- `git log --merge` \
*Показать конфликт слияний*

### Конфигурация
- `git config` \
*Управление конфигурацией Git*
    - `git config user.name` \
    *Получить текущее имя пользователя*
    - `git config user.email` \
    *Получить текущий email пользователя*
    - `git config --global user.name "xenongee"`
    - `git config --global user.email "rublgleb@gmail.com"` \
    *Установить глобальное[^1] имя пользователя и email*
    - `git config --list` \
    *Список всех настроек конфигурации*
        - `cat ~/.gitconfig` \
        *Просмотр содержимого глобального конфигурационного файла Git*

### Staging area
- `git add` \
*Добавить файл в Staging area (индекс)[^2] для отслеживания изменений*
    - `git add .` \
    *Добавить все изменённые файлы в текущем каталоге и подкаталогах*
    - `git add <file>` \
    *Добавить конкретный файл*
    - `git add -p` \
    *Интерактивно добавить файлы*

### Коммиты
- `git commit` \
*Создать коммит с изменениями из Staging area*
    - `git commit -m "commit message"` \
    *Создать коммит с сообщением*
    - `git commit -m "commit message" -m "additional commit message"` \
    *Создать коммит с сообщением и c дополнительным сообщением*
    - `git commit -am "commit message"` \
    *Создать коммит с сообщением, добавить все изменённые файлы (пропускаем этап добавления изменений в Staging area, однако вам все равно нужно запустить `git add`, чтобы начать отслеживать новые файлы)*
    - `git commit --amend` \
    *Изменить последний коммит* \
    *Сообщение коммита будет изменено во внешнем редакторе (nano\vim)* \
    *Для отправки изменения в файле не забудьте добавить файл в Staging area `git add` или `git add -a --amend`*
    - `git commit --amend -m "commit message"` \
    *Изменить последний коммит с сообщением*
    - `git commit --amend --no-edit` \
    *Изменить последний коммит без изменения сообщения*

## Checkout, ветки, слияние веток, HEAD [^3], тэги, switch
### Checkout
- `git checkout` \
*Переключиться на другой коммит, ветку или тег, откат файла к последнему коммиту*
    - `git checkout <..>` \
    *Переключиться на конкретный коммит или ветку*
    - `git checkout master\main` \
    *Переключиться на ветку master\main*
    - `git checkout -b <branch>` \
    *Создать новую ветку и переключиться на неё*
    - `git checkout --track <origin\branch>` \
    *Создать локальную ветку из удаленой ветки репозитория и переключиться на неё*

### Ветки
- `git branch` \
*Показать список веток*
    - `git branch -a` \
    *Показать список всех веток (локальные и удалённые)*
    - `git branch <branch>` [^5] \
    *Создать новую ветку [^4]*
    - `git branch -d [--delete] <branch>` \
    *Удалить ветку [^10]*
    - `git branch -vv`
    *Показать список веток включая удалённые*


### Слияние веток
- `git merge` \
  *Слияние веток [^6]*
  - `git merge <branch>` \
  *Слить ветку в текущую ветку*
  - `git merge --abort` \
  *Отменить слияние веток*

### Тэги
- `git tag` \
  *Показать список тегов*
  - `git tag <tag>` \
  *Создать новый тег*

### Switch (переключиться на другую ветку) [^7]
- `git switch <branch>` \
*Переключиться на другую ветку*
    - `git switch --detach <commit\tag>` \
    *Переключиться на конкретный коммит или тег*
    - `git switch -c <branch>` \
    *Создать новую ветку и переключиться на неё*

### Показать список файлов в рабочем дереве
- `git ls-files` \
*Показать список файлов в рабочем дереве*

## Удаление [^8]\откат изменений

### Откат изменений
- `git restore` \
*Отменить изменения в файлах*
    - `git restore --staged <file\path-to-file>` \
    *Отменить изменения в файле или директории в Staging area*
    - `git restore <file\path-to-file>` \
    *Отменить изменения в файле или директории в рабочем дереве*

### Удаление файлов
- `git rm` \
*Удалить файл из рабочего дерева и из индекса*
    - `git rm <file>` \
    *Удалить файл из рабочего дерева и из индекса*
    - `git rm -r <directory-with-files>` \
    *Удалить (рекурсивно) директорию с файлами из рабочего дерева и из индекса*
    - `git rm -f <file>` \
    *Удалить форсированно*
    - `git rm --cached <file>` \
    *Удалить кэшированную версию файла*

- `git clean` \
*Удалить неотслеживаемые файлы [^9] из рабочего дерева*
    - `git clean -n` \
    *Показать список файлов, которые будут удалены*
    - `git clean -d` \
    *Удалить неотслеживаемые файлы и директории из рабочего дерева*
    - `git clean -f` \
    *Удалить форсированно*
    - `git clean -dn`
    - `git clean -df`

- `git reset` \
*Отменить изменения в рабочем дереве и индексе*
  - `git reset --soft HEAD~1` \
  *Отменить последний коммит, изменения оставить и в файле, и в индексе*
  - `git reset HEAD~1` \
  *Отменить последний коммит, изменения оставить в файле, но не в индексе*
  - `git reset --hard HEAD~1` \
  *Перманентно удалить последний коммит с измененияями*

### Detached Commit in detached HEAD
Вносим изменения в уже совершённом коммите.

1. **Переход в режим Detached HEAD** \
Используем `git checkout` с идентификатором коммита, чтобы перейти в режим отсоединённой HEAD. \
В этом режиме HEAD указывает на определённый коммит, а не на ветку.

2. **Внесение изменений** \
Внесите необходимые изменения в файлы. Проверьте статус изменений: `git status` \
Добавьте изменения в индекс: `git add <file>`. Создайте новый коммит с изменениями: `git commit -m "commit message"`.

3. **Сохранение изменений** \
В режиме Detached HEAD *созданный коммит не привязан ни к одной ветке*. \
Чтобы сохранить изменения:
   - Создайте новую ветку на основе текущего коммита: \
     `git branch <new-branch-name>`
   - Переключитесь на созданную ветку: \
     `git switch <new-branch-name>`

4. **Слияние веток** \
Переключитесь на ветку `master`: `git switch master`. Соедините изменения из созданной ветки `git merge <new-branch-name>.` \
В случае конфликтов:
   - Разрешите конфликты вручную в файлах или через редактор (VS Code).
   - Добавьте исправленные файлы в индекс `git add <file>` и завершите слияние `git commit`

- **Просмотр коммитов через reflog** \
Используйте `git reflog`, чтобы просмотреть историю всех действий, включая создание коммитов, переключение веток и другие операции: \
Эта команда показывает хеши коммитов и временную метку каждой операции. Если коммит не привязан ни к одной ветке, он всё ещё может быть найден в `reflog` до удаления сборщиком мусора (GC). \
Чтобы восстановить такой коммит, можно переключиться на него или создать ветку, как это показано в шаге 3.

- **.gitignore** \
Чтобы игнорировать файлы, которые не нужно отслеживать, можно создать файл `.gitignore` в корневом каталоге репозитория. В этом файле можно указать список имен файлов или директорий, которые следует игнорировать.

- **.gitkeep** \
Если вы хотите, чтобы Git отслеживал пустые директории, можно создать в них файл `.gitkeep`. Этот файл не содержит никакого содержимого, но его наличие указывает на то, что директория должна быть отслеживаемой.

## Продвинутая работа с Git
### Stash
- `git stash` \
*Сохранить изменения в рабочем дереве в стек изменений (черновик, тайник) [^11]*
    - `git stash list` \
    *Показать список всех сохранённых stash*
    - `git stash apply` \
    *Применить изменения из последнего stash*
    - `git stash apply stash@{[index]}` \
    *Применить изменения из stash по индексу*
    - `git stash pop` \
    *Применить изменения из stash и удалить его из списка*
    - `git stash clear` \
    *Удалить все stash*

### Reflog
- `git reflog` \
*Показать список всех действий в репозитории*

### Fast-forward merge
Fast Forward Merge - это тип слияния, который происходит тогда, когда в основной ветке (main/master) нет новых коммитов с момента создания новой ветки. \
Подробнее:
1. Ветка, куда вы хотите выполнить слияние (например, main), не содержит новых коммитов после того момента, когда она разошлась с веткой, которую вы сливаете (например, feature).
2. Git просто перемещает указатель текущей ветки (HEAD) на последний коммит целевой ветки, без создания нового коммита слияния.
Fast Forward Merge невозможен в том случае, если в основной ветке (main\master) были новые коммиты после расхождения с новой веткой, то Fast Forward Merge невозможен. Git выполнит обычное слияние с созданием коммита слияния (merge commit).

### Recursive Merge
Recursive Merge используется, когда обе ветки (например, `master` и `develop`) содержат изменения, что делает Fast Forward Merge невозможным.

- **Как работает:** \
Git объединяет изменения из обеих веток, создавая merge commit.
- **Принудительное создание merge commit:** \
Используйте флаг `--no-ff`, даже если возможен Fast Forward Merge. \
По умолчанию: Recursive Merge является стандартным методом, если в обеих ветках есть изменения. При возникновении конфликтов требуется их ручное разрешение.

### Squash Merge
Squash Merge используется для объединения нескольких коммитов из ветки в один, чтобы упростить и улучшить читаемость истории изменений, особенно в случае, когда ветка содержит множество изменений, фиксов и пр.
- **Как работает:** \
Все коммиты из сливаемой ветки объединяются в один перед слиянием: `git merge --squash <branch>`
После выполнения `--squash` нужно вручную выполнить коммит: `git commit -m "Объединённые изменения из ветки <branch>"`

### Rebase Merge
Rebase Merge переписывает историю коммитов, добавляя изменения из одной ветки поверх другой.

- **Как работает:**
  Команда `git rebase <branch>` переносит все коммиты из текущей ветки (например `develop`, перед этим переключитесь на неё) на вершину указанной ветки (например `master`), создавая линейную историю. \
Используется, чтобы избежать merge commit'ов и сохранить историю более чистой.
Далее нужно переключиться на ветку, в которую вы хотите слить изменения: `git switch <branch>`
Затем выполнить `git merge <branch>` для слияния изменений.
- **Осторожность:** Rebase изменяет историю, поэтому не рекомендуется использовать его для веток, которые уже были опубликованы.

### Cherry-pick
- `git cherry-pick <commit>` \
*Добавить конкретные изменения из другой ветки в текущую ветку*

### Удаленный репозиторий
## Remote tracking branches
Remote Tracking Branch — это промежуточная ветка, которые используются для синхронизации изменений между локальным и удалённым репозиториями. \
Облегчает синхронизацию локальных изменений с удаленным репозиторием и наоборот, помогает в разрешении конфликтов и слиянии.

### Процесс отправки изменений в удалённый репозиторий
Имеется локальная мастер ветка (например, `master`) и удалённая ветка (например, `origin/master`). \
Создание Tracking Branch: \
При выполнении команды `git push`, Git создает Tracking Branch (локальное представление удалённого репозитория). \
Имена веток слежения имеют вид <remote>/<branch>. Например, если вы хотите посмотреть, как выглядела ветка master на сервере origin во время последнего соединения с ним, используйте ветку origin/master. Если вы с коллегой работали над одной задачей и он отправил на сервер ветку iss53, при том что у вас может быть своя локальная ветка iss53, удалённая ветка будет представлена веткой слежения с именем origin/iss53
Отправка изменений: \
Через Tracking Branch изменения отправляются в удалённый репозиторий (Remote). \

### Работа с различными ветками
Отправка изменений в новые ветки: Требует явного указания, куда отправить изменения (упоминание о Upstream).
Симуляция работы в команде: Создание и редактирование новой фича-ветки непосредственно в удаленном репозитории через web interface.
Fetch изменений: Команда git fetch позволяет увидеть новые или измененные ветки в удаленном репозитории.
Важность Tracking Branch
Tracking Branch выполняет критически важную роль в процессе синхронизации и объединения изменений между локальными и удаленными репозиториями, обеспечивая эффективную командную работу и конфликт-резолюцию.

- `git push <remote> <branch>`
  *Отправка изменений в удалённый репозиторий*
  - `git push --set-upstream <remote> <branch>`
  *Отправка изменений в удалённый репозиторий и создание Tracking Branch*

- `git fetch` \
*Получение изменений из удалённого репозитория*

- `git pull` \
*Синхронизация локальных изменений с удаленным репозиторием (эквивалентно `git fetch` + `git merge`)*

## Local tracking branches
Local Tracking Branches - это локальные ветки, связанные с удалёнными ветками, позволяющие отслеживать их изменения для удобного выполнения команд `git pull` и `git push`.

Пример использования:
- При работе с веткой Master, которая связана с Remote Origin Master, команда `git pull` влечёт за собой загрузку изменений из удалённой ветки в локальную. Аналогично, `git push` отправляет изменения из локальной ветки в удалённую.
- Установление трекинга для ветки происходило автоматически при её создании, если выполняется `git branch` с подробным выводом, можно увидеть, что локальная ветка master уже отслеживает изменения в origin/master.

- `git branch --track <local_branch> <remote_branch>` \
*Начать трекинг определённой удалённой ветки - это создает локальную ветку и связывает ее с удалённой веткой*

Практический пример:
- Если нужно отслеживать изменения в удалённой ветке dev/remote, сначала проверяем наличие интересующей удалённой ветки командой `git branch -a`
- Затем создаём локальную ветку и устанавливаем трекинг через `git branch --track dev/remote origin/dev/remote`.
- После выполнения этих шагов, любые изменения в origin/dev/remote будут синхронизироваться с локальной веткой dev/remote при выполнении `git pull`.

## Upstream, Origin
Upstream - это отслеживаемая ветка, связанная с удалённой веткой.
Origin - это удаленный репозиторий Git, он может быть назван как угодно, но обычно это просто `origin`.

- `git push -u origin master` \
*Создание внешней ветки (если не существует) и использование ее в качестве Upstream для отправки изменений*

### Клонирование, добавление и просмотр удалённых репозиториев
- `git clone <url>` \
*Клонирование репозитория*

- `git remote add <name> <url>` \
*Добавление удалённого репозитория*

- `git remote -v` \
*Просмотр удалённых репозиториев*

### Удаление remote branches
При попытке удалить удаленную ветку (tracking branch) локально через `git branch -d <origin/branch>>` произойдет ошибка, так как ветка не найдена.
- `git branch -d --remote [-r] <origin/branch>` \
  *Удаление удалённой ветки*

Ветка исчезнет из локального списка, но останется в удаленном репозитории. \
Используйте `git ls-remote` для просмотра списка удаленных веток.

Для удаления ветки во внешнем репозитории используйте: `git push origin --delete <branch>`. После этого команда `git ls-remote` покажет, что ветка удалена из удаленного репозитория.

Удаление ветки из удаленного репозитория предотвращает доступ других пользователей к этой ветке через репозиторий. \
Если у кого-то осталась копия ветки локально, он может снова запушить ее изменения, и ветка появится в репозитории заново.




[^1]: Глобальная конфигурация применяется ко всем репозиториям в системе.
[^2]: **Staging area** (индекс, область подготовленных изменений) --- это промежуточная область, где фиксируются изменения перед их сохранением в истории репозитория. Это позволяет разработчику управлять тем, какие изменения войдут в следующий коммит. \
Перед тем, как изменения в файле будут зафиксированы (с помощью commit), файл должен быть добавлен в эту область. \
\
-- Изначально файл Untracked (неотслеживаемый). После выполнения команды `git add` файл становится Staged (отслеживаемый). \
-- После выполнения команды `git commit` файл приобретает статус Unmodified (неизмененный) или Commited (зафиксированный). \
-- При удалении файла из рабочего дерева он получает статус Unmodified (неизмененный). \
-- При внесении изменений в файл он становится Modified (измененный), затем с помощью команды `git add` переходит в состояние Staged (отслеживаемый).
[^3]: **HEAD** --- это указатель Git, который показывает на текущий коммит в репозитории. Это тот коммит, от которого будут проходить дальнейшие изменения или коммиты. \
При переключении между ветками командой `git checkout`, HEAD автоматически перемещается на последний коммит выбранной ветки. После внесения изменений в файлы, добавления их в Staging area и создания нового коммита, HEAD обновляется и указывает на этот новый коммит в текущей ветке. \
**Detached HEAD** --- состояние указателя HEAD, при котором он ссылается на определённый коммит, а не на ветку. Вы можете перейти к конкретному коммиту, чтобы изучить состояние репозитория в точке этого коммита. HEAD будет указывать на выбранный коммит без привязки к ветке. \
Файл `.git/HEAD`: Внутри скрытой папки `.git` находится файл `HEAD`, содержащий сведения о текущем положении HEAD. Используя команды типа `cat .git/HEAD`, можно узнать, на какой коммит или ветку в данный момент указывает HEAD. \
Возвращение к ветке: Чтобы выйти из состояния Detached HEAD и вернуться к работе с ветками, достаточно выполнить git checkout на имя ветки, например, в master. Таким образом, HEAD снова будет указывать на последний коммит активной ветки.
[^4]: Cоздания новой ветки не влияет на основную master ветку. После разработки новой функциональности на новой ветке, она может быть слита с основной master веткой.
[^5]: Название ветки может содержать только буквы, цифры, дефисы и символы подчёркивания, но может содержать пробелы.
[^6]: **Слияние веток** (branch merge) --- это процесс объединения изменений из одной ветки в другую. Это позволяет разработчикам объединять изменения из разных веток в одну ветку, чтобы создать единую историю коммитов. \
Процесс слияния: \
-- Переключиться на ветку, в которую нужно слить изменения - `git checkout master`. \
-- Выполнить слияние - `git merge devBranch`. \
При слиянии ветки X в ветку Y, ветка X не удаляется сама по себе.
[^7]: **Команда** `git switch` --- альтернатива `git checkout` для переключения между ветками. В отличие от `git checkout`, команда `git switch` специализируется только на переключении веток и включает дополнительные проверки безопасности. Например, она автоматически остановит операцию, если обнаружит риск потери несохраненных локальных изменений. Однако с помощью ключа `--detach` можно переключиться на конкретный коммит или тег.
[^8]: **Команда** `git restore` --- альтернатива `git checkout` для отката изменений, возвращая последний коммит указанного файла. \
Удалить файл можно простым способом, так и альтернативным. \
\
Простой способ: \
-- Удалить файл с помощью команды `rm -rf <filename>`, либо через графический интерфейс. \
-- Проверяем что файл\директория удалены через `git status` и добавляем изменения в Staging area с помощью `git add .`. \
-- Создаем коммит с помощью `git commit -m "message"`. \
\
Альтернативный способ с помощью команды `git rm <filename>`: \
-- Удалить файл с помощью команды `git rm <filename>`. \
-- Проверяем что файл\директория удалены через `git status` или `git ls-files`. \
-- Создаем коммит с помощью `git commit -m "message"`.
[^9]: **Команда** `git clean` используется для удаления неотслеживаемых файлов и директорий из рабочего дерева. Неотслеживаемые файлы --- это файлы, которые не были добавлены в индекс с помощью `git add` и не были зафиксированы в коммите. \
Использование `git clean -n` (или `-dn`) для предварительного просмотра удаляемых файлов и `git clean -f` (или `-df`) для фактического удаления.\
Еще раз: `git clean` удаляет только файлы, не добавленные в индекс (не staged)
[^10]: До удаления ветки нужно убедиться, что вы не находитесь в этой ветке. Используйте `git branch` для просмотря текущей ветки. \
Если попытаться удалить ветку, находясь в ней, Git выдаст ошибку об использовании ветки. \
Используйте `git log` и `git branch` для проверки, была ли ветка успешно удалена. Убеждаемся в отсутствии удалённой ветки в списке. \
Важное замечание: При удалении ветки все невлитые коммиты тоже удаляются. Следует удалять ветку только после того, как её изменения были влиты в главную ветку и ветка больше не нужна. \
Это поможет поддерживать проект организованным и сократить количество неактивных веток.
[^11]: **Команда** `git stash` используется для временного сохранения изменений в рабочем дереве, чтобы вы могли переключиться на другую ветку или выполнить другие операции, не затрагивая текущие изменения. \
Раньше без этой команды нужно было коммитить изменения, создавать новую ветку, а затем удалить коммит из исходной ветки. \
[^12]:
[^13]:
[^14]:
[^15]:
[^16]:
[^17]:
[^18]:
[^19]:
[^20]:
